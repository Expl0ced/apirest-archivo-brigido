"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Folder = void 0;
var client_1 = require("../lib/client");
var Folder = /** @class */ (function (_super) {
    __extends(Folder, _super);
    function Folder(host, token) {
        var _this = _super.call(this, 'folder', host, token) || this;
        _this.host = host;
        _this.token = token;
        return _this;
    }
    /**
     * Returns a list of a folder's details.
     *
     * @param folderKey - The key of the folder you wish to load
     */
    Folder.prototype.getInfo = function (folderKey, details) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('get_info.php', { folderKey: folderKey, details: details })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Specifies how deep in the folder structure, how far from root, the target folder is.
     * The number of levels deep is returned with a list of "chain folders" which
     * illustrate the direct path from root to the target folder.
     *
     * @param folderKey - The key of the folder you wish to load the depth of
     */
    Folder.prototype.getDepth = function (folderKey) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('get_depth.php', { folderKey: folderKey })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Returns a collection of top-level folders or files for target folder.
     *
     * @param folderKey - The key of the folder you wish to load the contents for
     * @param contentType - Specifies the type of content to return
     * @param chunk - Specifies which segment of the results to return starting from one
     * @param chunkSize - The number of items to include in each chunk returned (0-1000)
     * @param orderDirection - Whether to sort ascending or descending
     * @param orderBy - Key of the column by which to sort
     * @param filter - Filter by privacy and/or by filetype
     */
    Folder.prototype.getContent = function (folderKey, contentType, chunk, chunkSize, details, orderDirection, orderBy, filter) {
        if (chunk === void 0) { chunk = 0; }
        if (chunkSize === void 0) { chunkSize = 100; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('get_content.php', {
                            folderKey: folderKey, contentType: contentType, chunk: chunk, chunkSize: chunkSize, details: details, orderDirection: orderDirection, orderBy: orderBy, filter: filter,
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Updates a folder's information.
     */
    Folder.prototype.update = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('update.php')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Move one or more user's folders to target destination.
     */
    Folder.prototype.move = function (folderKeySrc, folderKeyDst) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('move.php', {
                            folderKeySrc: folderKeySrc, folderKeyDst: folderKeyDst,
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Copies a session user's folder and its children to a target destination.
     */
    Folder.prototype.copy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('copy.php')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Deletes one or more session user's folders by moving them and their
     * contents into the trash and setting their delete dates.
     */
    Folder.prototype.delete = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('delete.php')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Deletes one or more of a session user's folders permanently,
     * along with all contents of the folders, by removing their entries from the database.
     * THIS OPTION CANNOT BE UNDONE.
     */
    Folder.prototype.purge = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('purge.php')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Activates, or deactivates, a folder as a file drop.
     * Alternatively, updates the folder's file drop configuration.
     */
    Folder.prototype.configureFiledrop = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('configure_filedrop.php')];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Searches the the content of a given folder.
     *
     * @param folderKey - The key of the folder you wish to load the depth of.
     * @param searchText - The search keywords to look for in filenames, folder names, and descriptions.
     * @param searchAll - If folder_key is passed, then this parameter is ignored. If folder_key is not passed, search_all can be used to indicate whether to search the root folder only or the entire device (default 'yes').
     * @param details - If "yes", the API returns the total_files, total_folders, and total_size for all the contained folders and files recursively of each folder. However, there is a limit on how many items can be counted. If the limit is reached, an extra property overflow will be returned as well. If "shallow" is specified, the API returns the byte_count of files immediately inside each folder (non-recursive).
     * @param filter - Filter by privacy and/or by filetype. This is a comma-separated list of file types and privacy options. Can take one or more of the following values : "public", "private", "image", "video", "audio", "document", "spreadsheet", "presentation", "application", "archive", "data", and "development".
     */
    Folder.prototype.search = function (folderKey, searchText, searchAll, details, filter) {
        if (searchAll === void 0) { searchAll = true; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.post('search.php', {
                            folderKey: folderKey,
                            searchText: searchText,
                            searchAll: searchAll,
                            details: details,
                            filter: filter,
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return Folder;
}(client_1.Client));
exports.Folder = Folder;
